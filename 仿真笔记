1、保证停留时间=下载时间
2、如何用message模拟数据包
3、移动模型要求：
（1）确定性单条路径，选定起点、终点，依据规则选取路径，路径上选取停留点并设置停留时间。
（2）概率性多条路径，选定起点、终点，依据不同规则选取多条路径，并设置选择概率，在每条路径上设置停留点和停留时间。
4、由设计的移动模型输出，用户-候选缓存区域位置（到达概率），用户-候选缓存区域（停留时间）的矩阵。由此计算并选择缓存区域位置。
5、候选缓存区域位置：（1）用户停留点所在区域（2）用户经过的所有区域
6、缓存区域效果实现：在正中设置
7、移动模型设计目标：（1）中间多个停留点，每个停留点（wp）有停留时间；（2）当节点运动到目的地时，设置节点move为inactive。
                    注：在RandomWaypoint移动模式上实现，源码中是path之间有waitTime，将其修改为wp之间有waitTime。
8、move过程：
（1）起点-判断当前时间<nextTimeToMove？return ：（是否有下一个destination？没有则通过getPath获取nextWp，若不成功则return）
之后move并判断是否到达destination。
（2）是否到达当前destination？设置下次移动开始时间（当前时间+随机的等待时间），destination设置为当前位置，距离计算归零
（3）在movementModel中，path有几个wp，则会有几次从当前location到wp的过程（包括wp为当前location的情况）。
9、host的
(1)isMovementActive()函数返回此host的move是否可用
       可以通过在采用的不同movement中重写父类movementModel的isActive（）方法来定义不同情况下isMovementActive（）函数的返回值，
   以此实现需求场景下enable或disable节点host的move。 
(2)isRadioActive()函数返回此host的通信是否可用
       可以通过采用在采用的不同NetworkInterface中重写父类NetworkInterface的isActive（）方法来定义不同情况下isRadioActive()函数的返回值，
   以此实现需求场景下enable或disable节点host的通信。
10、算法验证过程：
    （1）获取到节点经过的网格grid及停留时间gridAndTime；
    （2）依据预测矩阵，结合完成内容所需的缓存区域停留时间上限，选择并设置缓存区域；
    （3）实现节点在缓存区域内接收数据时间=停留时间；
    （4）获取系统运行过程中节点在缓存区域内获取数据时间+系统在缓存区域外通过d2d获取数据时间，据此计算通过基站获取数据时间，计算平均下载时延；
    （5）评价算法性能
    注：A、节点网格停留时间gridAndTime=节点动态经过网格平均停留时间（多次实验取得）+节点静止在网格停留时间（提前设置，可反应在预测网格中）
        B、缓存区域停留时间上限：由传输的数据量和d2d传输速率决定。两种特殊情况：若停留时间上限过小，则每个节点只经过一个缓存区域即可，停留时间的作用被弱化，
        只需要找出经过轨迹数最多的网格；若停留时间上限过大，则节点经过所有缓存区域也不会有停留时间溢出的问题，则直接选取给所有节点停留时间收益最大的网格即可，
        停留时间依然起作用，但停留时间上限不会起到约束作用。
        C、停留时间上限要起作用，必须设置节点接收完所有数据后不再接收数据。
11、评价指标为用户在缓存区域内下载的时间，即停留时间被停留时间上限截取之后的部分（而非停留的时间长短）
12、（1）网格轨迹数排序选择（2）网格无停留时间上限的排序选择（3）本文的网格有停留时间限制的排序选择
13、模拟缓存区域存储数据包并提供下载服务：（1）缓存区域存有所有请求节点需求的数据（2）缓存区域对通信范围内的服务节点提供数据服务
